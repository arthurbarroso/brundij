{
"version":3,
"file":"goog.loader.abstractmodulemanager.js",
"lineCount":77,
"mappings":"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",
"sources":["goog/loader/abstractmodulemanager.js"],
"sourcesContent":["/**\n * @license\n * Copyright The Closure Library Authors.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The interface for module managers. The default implementation\n * is goog.module.ModuleManager.\n */\n\ngoog.provide('goog.loader.AbstractModuleManager');\ngoog.provide('goog.loader.AbstractModuleManager.CallbackType');\ngoog.provide('goog.loader.AbstractModuleManager.FailureType');\n\ngoog.require('goog.module.AbstractModuleLoader');\ngoog.require('goog.module.ModuleInfo');\ngoog.require('goog.module.ModuleLoadCallback');\ngoog.require('goog.module.ModuleLoadFailureType');\ngoog.requireType('goog.html.TrustedResourceUrl');\n\n\n\n/**\n * The ModuleManager keeps track of all modules in the environment.\n * Since modules may not have their code loaded, we must keep track of them.\n * @abstract\n * @constructor\n * @struct\n */\ngoog.loader.AbstractModuleManager = function() {\n  'use strict';\n  /**\n   * The module context needed for module initialization.\n   * @private {?Object}\n   */\n  this.moduleContext_ = null;\n\n  /**\n   * A loader for the modules that implements loadModules(ids, moduleInfoMap,\n   * opt_successFn, opt_errorFn, opt_timeoutFn, opt_forceReload) method.\n   * @private {?goog.module.AbstractModuleLoader}\n   */\n  this.loader_ = null;\n};\n\n\n/**\n * The type of callbacks that can be registered with the module manager,.\n * @enum {string}\n */\ngoog.loader.AbstractModuleManager.CallbackType = {\n  /**\n   * Fired when an error has occurred.\n   */\n  ERROR: 'error',\n\n  /**\n   * Fired when it becomes idle and has no more module loads to process.\n   */\n  IDLE: 'idle',\n\n  /**\n   * Fired when it becomes active and has module loads to process.\n   */\n  ACTIVE: 'active',\n\n  /**\n   * Fired when it becomes idle and has no more user-initiated module loads to\n   * process.\n   */\n  USER_IDLE: 'userIdle',\n\n  /**\n   * Fired when it becomes active and has user-initiated module loads to\n   * process.\n   */\n  USER_ACTIVE: 'userActive'\n};\n\n\n/**\n * The possible reasons for a module load failure callback being fired.\n * @enum {number}\n */\ngoog.loader.AbstractModuleManager.FailureType =\n    goog.module.ModuleLoadFailureType;\n\n\n/**\n * A non-HTTP status code indicating a corruption in loaded module.\n * This should be used by a ModuleLoader as a replacement for the HTTP code\n * given to the error handler function to indicated that the module was\n * corrupted.\n * This will set the forceReload flag on the loadModules method when retrying\n * module loading.\n * @type {number}\n */\ngoog.loader.AbstractModuleManager.CORRUPT_RESPONSE_STATUS_CODE = 8001;\n\n\n/**\n * Sets the batch mode as enabled or disabled for the module manager.\n * @param {boolean} enabled Whether the batch mode is to be enabled or not.\n */\ngoog.loader.AbstractModuleManager.prototype.setBatchModeEnabled = function(\n    enabled) {};\n\n\n/**\n * Sets the concurrent loading mode as enabled or disabled for the module\n * manager. Requires a moduleloader implementation that supports concurrent\n * loads. The default {@see goog.module.ModuleLoader} does not.\n * @param {boolean} enabled\n */\ngoog.loader.AbstractModuleManager.prototype.setConcurrentLoadingEnabled =\n    function(enabled) {};\n\n\n/**\n * Sets the module info for all modules. Should only be called once.\n *\n * @param {!Object<!Array<string>>} infoMap An object that contains a mapping\n *    from module id (String) to list of required module ids (Array).\n */\ngoog.loader.AbstractModuleManager.prototype.setAllModuleInfo = function(\n    infoMap) {};\n\n\n/**\n * Sets the module info for all modules. Should only be called once. Also\n * marks modules that are currently being loaded.\n *\n * @param {string=} opt_info A string representation of the module dependency\n *      graph, in the form: module1:dep1,dep2/module2:dep1,dep2 etc.\n *     Where depX is the base-36 encoded position of the dep in the module list.\n * @param {!Array<string>=} opt_loadingModuleIds A list of moduleIds that\n *     are currently being loaded.\n */\ngoog.loader.AbstractModuleManager.prototype.setAllModuleInfoString = function(\n    opt_info, opt_loadingModuleIds) {};\n\n\n/**\n * Gets a module info object by id.\n * @param {string} id A module identifier.\n * @return {!goog.module.ModuleInfo} The module info.\n * @abstract\n */\ngoog.loader.AbstractModuleManager.prototype.getModuleInfo = function(id) {};\n\n/**\n * Register an extra runtime module dependency. After an extra edge is added,\n * any subsequent calls to load or loadMultiple will fetch toModule if the\n * fromModule was loaded.\n *\n * The mechanism for this is implementation dependent. If the implementation\n * does not support extra edges, it will throw an error.\n * @param {string} fromModule The dependent module of the extra edge.\n * @param {string} toModule The module dependency of the extra edge.\n */\ngoog.loader.AbstractModuleManager.prototype.addExtraEdge = function(\n    fromModule, toModule) {\n  'use strict';\n  throw new Error('addExtraEdge is not implemented.');\n};\n\n/**\n * Remove an existing extra edge previously added by `addExtraEdge`.\n *\n * If the implementation does not support extra edges, it will throw an error.\n * @param {string} fromModule The dependent module of the extra edge.\n * @param {string} toModule The module dependency of the extra edge.\n */\ngoog.loader.AbstractModuleManager.prototype.removeExtraEdge = function(\n    fromModule, toModule) {\n  'use strict';\n  throw new Error('removeExtraEdge is not implemented.');\n};\n\n/**\n * Sets the module uris.\n * @param {!Object<string, !Array<!goog.html.TrustedResourceUrl>>} moduleUriMap\n *     The map of id/uris pairs for each module.\n */\ngoog.loader.AbstractModuleManager.prototype.setModuleTrustedUris = function(\n    moduleUriMap) {};\n\n\n/**\n * Gets the application-specific module loader.\n * @return {?goog.module.AbstractModuleLoader} the loader.\n */\ngoog.loader.AbstractModuleManager.prototype.getLoader = function() {\n  'use strict';\n  return this.loader_;\n};\n\n\n/**\n * Sets the application-specific module loader.\n * @param {!goog.module.AbstractModuleLoader} loader\n */\ngoog.loader.AbstractModuleManager.prototype.setLoader = function(loader) {\n  'use strict';\n  this.loader_ = loader;\n};\n\n\n/**\n * Gets the module context to use to initialize the module.\n * @return {?Object} The context.\n */\ngoog.loader.AbstractModuleManager.prototype.getModuleContext = function() {\n  'use strict';\n  return this.moduleContext_;\n};\n\n\n/**\n * Sets the module context to use to initialize the module.\n * @param {!Object} context The context.\n */\ngoog.loader.AbstractModuleManager.prototype.setModuleContext = function(\n    context) {\n  'use strict';\n  this.moduleContext_ = context;\n};\n\n\n/**\n * Determines if the ModuleManager is active\n * @return {boolean} TRUE iff the ModuleManager is active (i.e., not idle).\n */\ngoog.loader.AbstractModuleManager.prototype.isActive = function() {\n  'use strict';\n  return false;\n};\n\n\n/**\n * Determines if the ModuleManager is user active\n * @return {boolean} TRUE iff the ModuleManager is user active (i.e., not idle).\n */\ngoog.loader.AbstractModuleManager.prototype.isUserActive = function() {\n  'use strict';\n  return false;\n};\n\n\n/**\n * Preloads a module after a short delay.\n *\n * @param {string} id The id of the module to preload.\n * @param {number=} opt_timeout The number of ms to wait before adding the\n *     module id to the loading queue (defaults to 0 ms). Note that the module\n *     will be loaded asynchronously regardless of the value of this parameter.\n * @return {!IThenable}\n * @abstract\n */\ngoog.loader.AbstractModuleManager.prototype.preloadModule = function(\n    id, opt_timeout) {};\n\n\n/**\n * Prefetches a JavaScript module and its dependencies, which means that the\n * module will be downloaded, but not evaluated. To complete the module load,\n * the caller should also call load or execOnLoad after prefetching the module.\n *\n * @param {string} id The id of the module to prefetch.\n */\ngoog.loader.AbstractModuleManager.prototype.prefetchModule = function(id) {\n  'use strict';\n  throw new Error('prefetchModule is not implemented.');\n};\n\n\n/**\n * Records that the currently loading module was loaded. Also initiates loading\n * the next module if any module requests are queued. This method is called by\n * code that is generated and appended to each dynamic module's code at\n * compilation time.\n *\n * @abstract\n */\ngoog.loader.AbstractModuleManager.prototype.setLoaded = function() {};\n\n\n/**\n * Gets whether a module is currently loading or in the queue, waiting to be\n * loaded.\n * @param {string} id A module id.\n * @return {boolean} TRUE iff the module is loading.\n * @abstract\n */\ngoog.loader.AbstractModuleManager.prototype.isModuleLoading = function(id) {};\n\n\n/**\n * Requests that a function be called once a particular module is loaded.\n * Client code can use this method to safely call into modules that may not yet\n * be loaded. For consistency, this method always calls the function\n * asynchronously -- even if the module is already loaded. Initiates loading of\n * the module if necessary, unless opt_noLoad is true.\n *\n * @param {string} moduleId A module id.\n * @param {!Function} fn Function to execute when the module has loaded.\n * @param {!Object=} opt_handler Optional handler under whose scope to execute\n *     the callback.\n * @param {boolean=} opt_noLoad TRUE iff not to initiate loading of the module.\n * @param {boolean=} opt_userInitiated TRUE iff the loading of the module was\n *     user initiated.\n * @param {boolean=} opt_preferSynchronous TRUE iff the function should be\n *     executed synchronously if the module has already been loaded.\n * @return {!goog.module.ModuleLoadCallback} A callback wrapper that exposes\n *     an abort and execute method.\n * @abstract\n */\ngoog.loader.AbstractModuleManager.prototype.execOnLoad = function(\n    moduleId, fn, opt_handler, opt_noLoad, opt_userInitiated,\n    opt_preferSynchronous) {};\n\n\n/**\n * Loads a module, returning an IThenable for keeping track of the result.\n *\n * @param {string} moduleId A module id.\n * @param {boolean=} opt_userInitiated If the load is a result of a user action.\n * @return {!IThenable} A deferred object.\n * @abstract\n */\ngoog.loader.AbstractModuleManager.prototype.load = function(\n    moduleId, opt_userInitiated) {};\n\n\n/**\n * Loads a list of modules, returning a map of IThenables for keeping track of\n * the results.\n *\n * @param {!Array<string>} moduleIds A list of module ids.\n * @param {boolean=} opt_userInitiated If the load is a result of a user action.\n * @return {!Object<string, !IThenable>} A mapping from id (String)\n *     to deferred objects that will callback or errback when the load for that\n *     id is finished.\n * @abstract\n */\ngoog.loader.AbstractModuleManager.prototype.loadMultiple = function(\n    moduleIds, opt_userInitiated) {};\n\n\n/**\n * Method called just before module code is loaded.\n * @param {string} id Identifier of the module.\n * @abstract\n */\ngoog.loader.AbstractModuleManager.prototype.beforeLoadModuleCode = function(\n    id) {};\n\n\n/**\n * Register an initialization callback for the currently loading module. This\n * should only be called by script that is executed during the evaluation of\n * a module's javascript. This is almost equivalent to calling the function\n * inline, but ensures that all the code from the currently loading module\n * has been loaded. This makes it cleaner and more robust than calling the\n * function inline.\n *\n * If this function is called from the base module (the one that contains\n * the module manager code), the callback is held until #setAllModuleInfo\n * is called, or until #setModuleContext is called, whichever happens first.\n *\n * @param {!Function} fn A callback function that takes a single argument\n *    which is the module context.\n * @param {!Object=} opt_handler Optional handler under whose scope to execute\n *     the callback.\n */\ngoog.loader.AbstractModuleManager.prototype.registerInitializationCallback =\n    function(fn, opt_handler) {};\n\n\n/**\n * Register a late initialization callback for the currently loading module.\n * Callbacks registered via this function are executed similar to\n * {@see registerInitializationCallback}, but they are fired after all\n * initialization callbacks are called.\n *\n * @param {!Function} fn A callback function that takes a single argument\n *    which is the module context.\n * @param {!Object=} opt_handler Optional handler under whose scope to execute\n *     the callback.\n */\ngoog.loader.AbstractModuleManager.prototype.registerLateInitializationCallback =\n    function(fn, opt_handler) {};\n\n\n/**\n * Sets the constructor to use for the module object for the currently\n * loading module. The constructor should derive from\n * {@see goog.module.BaseModule}.\n * @param {!Function} fn The constructor function.\n */\ngoog.loader.AbstractModuleManager.prototype.setModuleConstructor = function(\n    fn) {};\n\n\n/**\n * The function to call if the module manager is in error.\n * @param {!goog.loader.AbstractModuleManager.CallbackType|!Array<\n *     !goog.loader.AbstractModuleManager.CallbackType>} types The callback\n *         type.\n * @param {!Function} fn The function to register as a callback.\n */\ngoog.loader.AbstractModuleManager.prototype.registerCallback = function(\n    types, fn) {};\n"],
"names":["goog","provide","require","requireType","loader","AbstractModuleManager","goog.loader.AbstractModuleManager","moduleContext_","loader_","CallbackType","ERROR","IDLE","ACTIVE","USER_IDLE","USER_ACTIVE","FailureType","module","ModuleLoadFailureType","CORRUPT_RESPONSE_STATUS_CODE","prototype","setBatchModeEnabled","goog.loader.AbstractModuleManager.prototype.setBatchModeEnabled","enabled","setConcurrentLoadingEnabled","goog.loader.AbstractModuleManager.prototype.setConcurrentLoadingEnabled","setAllModuleInfo","goog.loader.AbstractModuleManager.prototype.setAllModuleInfo","infoMap","setAllModuleInfoString","goog.loader.AbstractModuleManager.prototype.setAllModuleInfoString","opt_info","opt_loadingModuleIds","getModuleInfo","goog.loader.AbstractModuleManager.prototype.getModuleInfo","id","addExtraEdge","goog.loader.AbstractModuleManager.prototype.addExtraEdge","fromModule","toModule","Error","removeExtraEdge","goog.loader.AbstractModuleManager.prototype.removeExtraEdge","setModuleTrustedUris","goog.loader.AbstractModuleManager.prototype.setModuleTrustedUris","moduleUriMap","getLoader","goog.loader.AbstractModuleManager.prototype.getLoader","setLoader","goog.loader.AbstractModuleManager.prototype.setLoader","getModuleContext","goog.loader.AbstractModuleManager.prototype.getModuleContext","setModuleContext","goog.loader.AbstractModuleManager.prototype.setModuleContext","context","isActive","goog.loader.AbstractModuleManager.prototype.isActive","isUserActive","goog.loader.AbstractModuleManager.prototype.isUserActive","preloadModule","goog.loader.AbstractModuleManager.prototype.preloadModule","opt_timeout","prefetchModule","goog.loader.AbstractModuleManager.prototype.prefetchModule","setLoaded","goog.loader.AbstractModuleManager.prototype.setLoaded","isModuleLoading","goog.loader.AbstractModuleManager.prototype.isModuleLoading","execOnLoad","goog.loader.AbstractModuleManager.prototype.execOnLoad","moduleId","fn","opt_handler","opt_noLoad","opt_userInitiated","opt_preferSynchronous","load","goog.loader.AbstractModuleManager.prototype.load","loadMultiple","goog.loader.AbstractModuleManager.prototype.loadMultiple","moduleIds","beforeLoadModuleCode","goog.loader.AbstractModuleManager.prototype.beforeLoadModuleCode","registerInitializationCallback","goog.loader.AbstractModuleManager.prototype.registerInitializationCallback","registerLateInitializationCallback","goog.loader.AbstractModuleManager.prototype.registerLateInitializationCallback","setModuleConstructor","goog.loader.AbstractModuleManager.prototype.setModuleConstructor","registerCallback","goog.loader.AbstractModuleManager.prototype.registerCallback","types"]
}
