{"version":3,"sources":["stylefy/impl/hashing.cljc"],"mappings":";AAIA,4CAAA,5CAAKA;AACL,AAAKC,sDAAyB,6CAAA,7CAACC;AAE/B;;;iDAAA,jDAAOC,0GAEJC;AAFH,AAGE,GAAQ,qCAAA,nCACE,wBAAA,vBAAMA,oCACN,OAASA,sCACT,gCAAAE,/BAAUF;AAHpB;AAAA,AAAA,MAAA,KAAAC,MAAA,CAAA,oOAAA,KAAA,vNAIQ,CAAA,qEAA0E,AAACE,wGAAOH;;;AAE1F,GAAM,wBAAA,vBAAMA;AAAqBJ;;AAAjC,GACM,OAASI;AAAqBA;;AADpC,GAEM,gCAAAE,/BAAUF;AAAqB,OAACI,eAAKJ;;AAF3C;;;;;AAIF,AAAA,AACA,AAAA,AAEA,+DAAA,/DAAOK,sIAAyCC;AAAhD,AACE,OAACC,+CACC,WAAKC,OAAOC;AAAZ,AACE,IAAMC,aAAW,AAACC,4CAAIL,UAAUG;IAE1BG,uBAAqB,EAAI,6DAAA,3DAAI,AAACC,0CAAuBH,mBACxB,AAACI,qBAAKJ,iBACN,AAACK,sBAAML,iBACb,CAACM,sFAAAA,kGAAAA,dAAiCN,8EAAAA,aAClCA;IAEvBO,qBAAmB,EAAI,EAAI,AAACH,qBAAKL,eACN,AAACM,sBAAMN,aACb,CAACO,sFAAAA,gGAAAA,ZAAiCP,4EAAAA,WAClCA;AAX3B,AAaE,GAAI,AAACS,6CAAET,SAASQ;AACd,OAACE,8CAAMX,OAAOC,SAASG;;oGACnBJ,/CACA,AAACY,sDAAOX,3GACR,OAACU,8GAAMF,mBAAmBL;;GACpCN,UACA,AAACe,eAAKf;;AAEV,wDAAA,xDAAOU,wHAAkCM;AAAzC,AACE,GACE,AAACT,0CAAuBS;AACxB,OAACC,2BAAoBD;;AAFvB,GAIE,AAACR,qBAAKQ;AACN,OAACjB,6DAAwCiB;;AAL3C,GAOE,AAACE,wBAAQF;AACT,OAACG,6CAAKT,sDAAiCM;;AARzC,GAUE,AAACI,qBAAKJ;AACN,OAACK,cAAI,AAACC,4CAAIZ,sDAAiCM;;AAX7C,GAaE,AAACP,sBAAMO;AACP,OAACM,4CAAIZ,sDAAiCM;;AAdxC,AAgBQA;;;;;;;;AAEV,kCAAA,lCAAMO,4EAAYC;AAAlB,AACE,GAAM,AAACC,cAAID;AAAX,AACE,IAGME,qCAAmC,4DAAA,2IAAA,vMAACZ,sDAAOU;IAK3CG,iBAAe,AAACjB,sDAAiCgB;IACjDE,eAAa,kBAAA,AAAAC,gBAAKtC,sDACH,AAACE,+CAA0B,AAAA,0HAA4B+B,QACvDlC;AAXrB,AAYE,qBAAA,bAAKsC,6DAAiB,AAACE,eAAKH;;AAbhC;;;AAeF,gDAAA,hDAAMI,wGAA0BC;AAAhC,AACE,OAACC,sBAAO1C,oDAAyB,AAAC2C,mBAAQ,AAAA,4HAA2BF","names":["stylefy.impl.hashing/default-class-prefix","stylefy.impl.hashing/use-custom-class-prefix?","cljs.core.atom","stylefy.impl.hashing/check-custom-class-prefix","custom-class-prefix","js/Error","cljs.core/Keyword","cljs.core.pr_str","cljs.core/name","stylefy.impl.hashing/recursively-convert-garden-units-in-map","style-map","cljs.core.reduce","result","prop-key","prop-value","cljs.core.get","converted-prop-value","stylefy.impl.utils/is-garden-value?","cljs.core/map?","cljs.core/coll?","stylefy.impl.hashing/recursively-convert-garden-units","converted-prop-key","cljs.core._EQ_","cljs.core.assoc","cljs.core.dissoc","cljs.core/keys","item","garden.compiler/render-css","cljs.core/vector?","cljs.core.mapv","cljs.core/set?","cljs.core/set","cljs.core.map","stylefy.impl.hashing/hash-style","style","cljs.core/seq","style-without-unnecessary-keywords","hashable-style","class-prefix","cljs.core/deref","cljs.core/hash","stylefy.impl.hashing/init-custom-class-prefix","options","cljs.core/reset!","cljs.core/boolean"],"sourcesContent":["(ns stylefy.impl.hashing\n  (:require [stylefy.impl.utils :as utils]\n            [garden.compiler :as compiler]))\n\n(def default-class-prefix \"_stylefy\")\n(def use-custom-class-prefix? (atom false))\n\n(defn- check-custom-class-prefix\n  \"Checks that the value is valid and returns as properly formatted prefix.\"\n  [custom-class-prefix]\n  (assert (or\n            (nil? custom-class-prefix)\n            (string? custom-class-prefix)\n            (keyword? custom-class-prefix))\n          (str \"Custom class prefix should be either string, keyword or nil, got: \" (pr-str custom-class-prefix)))\n\n  (cond (nil? custom-class-prefix) default-class-prefix\n        (string? custom-class-prefix) custom-class-prefix\n        (keyword? custom-class-prefix) (name custom-class-prefix)))\n\n(declare recursively-convert-garden-units)\n(declare recursively-remove-unnecessary-keywords)\n\n(defn- recursively-convert-garden-units-in-map [style-map]\n  (reduce\n    (fn [result prop-key]\n      (let [prop-value (get style-map prop-key)\n            ; Check the value and convert it if necessary.\n            converted-prop-value (if (or (utils/is-garden-value? prop-value)\n                                         (map? prop-value)\n                                         (coll? prop-value))\n                                   (recursively-convert-garden-units prop-value)\n                                   prop-value)\n            ; The key can also be a map or collection, check it.\n            converted-prop-key (if (or (map? prop-key)\n                                       (coll? prop-key))\n                                 (recursively-convert-garden-units prop-key)\n                                 prop-key)]\n\n        (if (= prop-key converted-prop-key)\n          (assoc result prop-key converted-prop-value)\n          (-> result\n              (dissoc prop-key)\n              (assoc converted-prop-key converted-prop-value)))))\n    style-map\n    (keys style-map)))\n\n(defn- recursively-convert-garden-units [item]\n  (cond\n    (utils/is-garden-value? item)\n    (compiler/render-css item)\n\n    (map? item)\n    (recursively-convert-garden-units-in-map item)\n\n    (vector? item)\n    (mapv recursively-convert-garden-units item)\n\n    (set? item)\n    (set (map recursively-convert-garden-units item))\n\n    (coll? item)\n    (map recursively-convert-garden-units item)\n\n    :else item))\n\n(defn hash-style [style]\n  (when (seq style)\n    (let [; Remove some unnecessary special keywords before hashing:\n          ; - sub-styles is only a link to other styles, it does not define the actual properties of this style\n          ; - class-prefix is only for class naming, the style looks the same with or without it\n          style-without-unnecessary-keywords (dissoc style :stylefy.core/sub-styles :stylefy.core/class-prefix)\n          ; Convert Garden units to CSS before hashing.\n          ; This makes sure Garden units have the same hash on both frontend and backend.\n          ; It also makes sure that Garden units and manually written units have the same hash.\n          ; For example: \"100px\" should be considered the same as (garden.units/px 100)\n          hashable-style (recursively-convert-garden-units style-without-unnecessary-keywords)\n          class-prefix (if @use-custom-class-prefix?\n                         (check-custom-class-prefix (:stylefy.core/class-prefix style))\n                         default-class-prefix)]\n      (str class-prefix \"_\" (hash hashable-style)))))\n\n(defn init-custom-class-prefix [options]\n  (reset! use-custom-class-prefix? (boolean (:use-custom-class-prefix? options))))\n"]}