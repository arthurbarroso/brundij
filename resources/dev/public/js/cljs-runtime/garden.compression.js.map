{"version":3,"sources":["garden/compression.cljc"],"mappings":";AAkCG;;;;8BAAA,sCAAAA,pEAAOG;AAAP,AAAA,IAAAF,aAAAD;UAAA,AAAAE,4CAAAD,WAAA,IAAA,jEAGIG;SAHJ,AAAAF,4CAAAD,WAAA,IAAA,hEAGQI;AAHR,AAIE,kBAAKC;AAAL,AACE,IAAAC,qBAAiB,AAACE,kBAAQJ,GAAGC;AAA7B,AAAA,oBAAAC;AAAA,AAAA,YAAAA,RAAWC;AAAX,AAAA,kDAAA,wDAAA,8DAAA,lEACQJ,4DACEI,2DACD,AAACE,gBAAMF;;AAHhB;;;;AAMJ,AAAA;;;;;;+BAAA,uCAAAG,tEAAOM;AAAP,AAAA,IAAAL,qBAAA;AAAA,AAAA,IAAAC,0BAAA,AAAA;AAAA,AAAA,IAAAC,wBAAA;;AAAA,AAAA,GAAA,CAAAA,wBAAAD;AAAA,AAAA,AAAAD,wBAAA,CAAA,UAAAE;;AAAA,eAAA,CAAAA,wBAAA;;;;AAAA;;;;AAAA,IAAAC,uBAAA,EAAA,CAAA,MAAA,AAAAH,4BAAA,AAAA,KAAAI,qBAAA,AAAAJ,yBAAA,KAAA,IAAA,OAAA;AAAA,AAAA,OAAAK,kEAAAF;;;AAAA,AAAA,CAAA,oEAAA,pEAAOE,+EAKFI;AALL,AAME,IAAMC,KAAG,AAACC,4CAAIpB,4BAASkB;AAAvB,AACE,kBAAKf;AAAL,AACE,sBAAA,WAAAkB,1BAACC;AAAD,AAAO,QAAAD,iDAAAA,oDAAAA,LAAGlB,gCAAAA;GAAGgB;;;;AARnB,CAAA,uDAAA,vDAAOL;;AAAP;AAAA,CAAA,iDAAA,WAAAC,5DAAOD;AAAP,AAAA,IAAAE,qBAAA;AAAA,AAAA,OAAAA,wDAAA,AAAAC,cAAAF;;;AAAA,AAWA;;;AAGEQ,0CACA,oHAAA,mFAAA,0DAAA,8BAAA,mFAAA,4DAAA,oBAAA,mFAAA,0DAAA,kBAAA,mFAAA,4DAAA,oBAAA,mFAAA,2DAAA,iBAAA,mFAAA,uDAAA,gBAAA,mFAAA,uDAAA,gBAAA,mFAAA,8DAAA,aAAA,mFAAA,wDAAA,cAAA,mFAAA,qEAAA,eAAA,mFAAA,mDAAA,3zDAACC;AAkBH;;;yCAAA,zCAAMC,0FAEHC;AAFH,AAGE,IAAOC,KAAGD;SAAV,LAAqBE;;AAArB,AACE,IAAAC,qBAAkC,AAACN,wCAAqBI;AAAxD,AAAA,oBAAAE;AAAA,IAAAC,aAAAD;IAAAC,iBAAA,AAAAC,4BAAAD;UAAA,AAAAE,4CAAAF,eAAA,jEAAiB7B;YAAjB,AAAA+B,4CAAAF,eAAA,nEAAqBzB;WAArB,AAAA2B,4CAAAF,eAAA,lEAA2BG;AAA3B,AACE,eAAO,AAACC,6CAAKP,GAAGM;eACT,CAAKL,+CAAG,iBAAAO,WAAMlC;IAANkC,eAAA,EAAA,CAAAA,oBAAAC,oBAAA,AAAAD,aAAA;AAAA,AAAA,QAAAA;KAAA;AACU9B;;;KADV;AAAA;;;KAAA;AAAA;;;KAAA;AAAA;;;KAAA;AAAA;;;KAAA;AAAA;;;KAAA;AAAA;;;KAAA;AAAA;;;KAAA;AAAA;;;KAAA;AAAA;;;;AAWEA;;;;;;;;AACjBuB","names":["p__69565","vec__69566","cljs.core.nth","garden.compression/token-fn","tag","re","s","temp__5735__auto__","chunk","cljs.core/re-find","cljs.core/count","var_args","args__4824__auto__","len__4818__auto__","i__4819__auto__","argseq__4825__auto__","cljs.core/IndexedSeq","garden.compression/tokenizer","seq69572","self__4806__auto__","cljs.core/seq","tags+regexes","fs","cljs.core.map","p1__69569#","cljs.core/some","garden.compression/stylesheet-tokenizer","garden.compression.tokenizer","garden.compression/compress-stylesheet","stylesheet","s1","s2","temp__5733__auto__","map__69579","cljs.core/--destructure-map","cljs.core.get","size","cljs.core.subs","G__69585","cljs.core/Keyword"],"sourcesContent":["(ns garden.compression\n  \"Stylesheet compression utilities.\"\n  #?(:clj\n     (:import (java.io StringReader StringWriter)\n               (com.yahoo.platform.yui.compressor CssCompressor))))\n\n;; ---------------------------------------------------------------------\n;; Clojure\n\n;; Clojure stylesheet compression leverages the YUI Compressor as it\n;; provides a performant and excellent solution to CSS compression.\n\n#?(:clj\n   (defn compress-stylesheet\n     \"Compress a stylesheet with the YUI CSSCompressor. Set\n  line-break-position to -1 for no line breaks, 0 for a line break\n  after each rule, and n > 0 for a line break after at most n\n  columns. Defaults to no -1\"\n     ([stylesheet]\n      (compress-stylesheet stylesheet -1))\n     ([^String stylesheet line-break-position]\n      (with-open [reader (StringReader. stylesheet)\n                  writer (StringWriter.)]\n        (doto (CssCompressor. reader)\n          (.compress writer line-break-position))\n        (str writer)))))\n\n;; ---------------------------------------------------------------------\n;; ClojureScript\n\n;; ClojureScript stylesheet compression uses a simple tokenizer and\n;; loop/recur to construct a new string of minified CSS.\n\n#?(:cljs\n   (defn- token-fn\n     \"Return a function which when given a string will return a map\n  containing the chunk of text matched by re, it's size, and tag.\"\n     [[tag re]]\n     (fn [s]\n       (when-let [chunk (re-find re s)]\n         {:tag tag\n          :chunk chunk\n          :size (count chunk)}))))\n\n#?(:cljs\n   (defn- tokenizer\n     \"Given an arbitrary number of [tag regex] pairs, return a function\n  which when given a string s will return the first matching token of s.\n  Token precedence is determined by the order of the pairs. The first\n  and last pairs have the highest and lowest precedence respectively.\"\n     [& tags+regexes]\n     (let [fs (map token-fn tags+regexes)]\n       (fn [s]\n         (some #(% s) fs)))))\n\n#?(:cljs\n   (def\n     ^{:private true\n       :doc \"Tokenizer used during stylesheet compression.\"}\n     stylesheet-tokenizer\n     (tokenizer\n      ;; String literals\n      [:string #\"^\\\"(?:\\\\.|[^\\\"])*\\\"\"]\n      ;; Delimiters\n      [:r-brace #\"^\\s*\\{\\s*\"]\n      [:l-brace #\"^;?\\s*}\"]\n      [:r-paren #\"^\\s*\\(\\s*\"]\n      [:l-paren #\"^\\s*\\)\"]\n      [:comma #\"^,\\s*\"]\n      [:colon #\"^:\\s*\"]\n      [:semicolon #\"^;\"]\n      ;; White space\n      [:space+ #\"^ +\"]\n      [:white-space+ #\"^\\s+\"]\n      ;; Everything else\n      [:any #\"^.\"])))\n\n#?(:cljs\n   (defn compress-stylesheet\n     \"Compress a string of CSS using a basic compressor.\"\n     [stylesheet]\n     (loop [s1 stylesheet s2 \"\"]\n       (if-let [{:keys [tag chunk size]} (stylesheet-tokenizer s1)]\n         (recur (subs s1 size)\n                (str s2 (case tag\n                          :string chunk\n                          :r-brace \"{\"\n                          :l-brace \"}\"\n                          :r-paren \"(\"\n                          :l-paren \")\"\n                          :comma \",\"\n                          :semi-comma \";\"\n                          :colon \":\"\n                          :space+ \" \"\n                          :white-space+ \"\"\n                          chunk)))\n         s2))))\n"]}