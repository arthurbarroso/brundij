{"version":3,"sources":["day8/re_frame_10x/navigation/epochs/events.cljs"],"mappings":"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","names":["day8.re-frame-10x.navigation.epochs.events/first-match-id","m","cljs.core/first","day8.re_frame_10x.inlined_deps.re_frame.v1v1v2.re_frame.core.reg_event_fx","day8.re-frame-10x.inlined-deps.re-frame.v1v1v2.re-frame.core/trim-v","p__49543","p__49544","map__49545","cljs.core/--destructure-map","cljs.core.get","vec__49546","cljs.core.nth","db","new-traces","temp__5733__auto__","sorted-traces","cljs.core.sort_by","map__49551","number-of-epochs-to-retain","cljs.core.get_in","events-to-ignore","cljs.core/vals","cljs.core.map","cljs.core/set","previous-traces","parse-state","day8.re-frame-10x.tools.metamorphic/initial-parse-state","drop-re-frame","drop-reagent","all-traces","cljs.core.into","day8.re-frame-10x.tools.metamorphic/parse-traces","new-matches","previous-matches","cljs.core.assoc","cljs.core.remove","match","event","day8.re-frame-10x.tools.metamorphic/matched-event","cljs.core/contains?","subscription-info","day8.re-frame-10x.tools.metamorphic/subscription-info","sub-state","day8.re-frame-10x.tools.metamorphic/initial-sub-state","subscription-match-state","day8.re-frame-10x.tools.metamorphic/subscription-match-state","subscription-matches","cljs.core/rest","new-sub-state","cljs.core/last","timing","cljs.core.mapv","epoch-traces","cljs.core.comp","day8.re-frame-10x.tools.coll/id-between-xf","start-of-epoch","event-handler-trace","cljs.core.filter","day8.re-frame-10x.tools.metamorphic/event-handler?","dofx-trace","day8.re-frame-10x.tools.metamorphic/event-dofx?","event-trace","day8.re-frame-10x.tools.metamorphic/event-run?","finish-run","or__4212__auto__","day8.re-frame-10x.tools.metamorphic/finish-run?","day8.re-frame-10x.tools.coll/last-in-vec","day8.re-frame-10x.tools.metamorphic/elapsed-time","sub-match","t","quiescent?","cljs.core/seq","day8.re-frame-10x.tools.metamorphic/quiescent?","all-matches","retained-matches","cljs.core/take-last","first-id-to-retain","retained-traces","p1__49541#","cljs.core.drop_while","trace","day8.re-frame-10x.tools.metamorphic/low-level-reagent-trace?","day8.re-frame-10x.tools.metamorphic/low-level-re-frame-trace?","cljs.core/assoc-in","cljs.core.update","epochs","selected-index","selected-id","cljs.core.juxt","cljs.core/identity","day8.re_frame_10x.inlined_deps.re_frame.v1v1v2.re_frame.core.path","p__49591","map__49592","_","temp__5737__auto__","match-ids","match-array-index","day8.re-frame-10x.tools.coll/find-index-in-vec","x","cljs.core._EQ_","new-id","cljs.core/count","p__49600","map__49601","p__49602","map__49603","p__49604","p__49605","map__49606","vec__49607","day8.re_frame_10x.inlined_deps.re_frame.v1v1v2.re_frame.core.reg_event_db","selected-epoch-id","app-db-before","day8.re-frame-10x.tools.metamorphic/app-db-before","cljs.core/reset!","re-frame.db/app-db","event-to-replay","re-frame.core/dispatch","cljs.core.dissoc","re-frame.trace/reset-tracing!","day8.re-frame-10x.tools.coll/dissoc-in","p__49610","vec__49611","match-id","temp__5739__auto__","new-db","day8.re-frame-10x.tools.metamorphic/app-db-after"],"sourcesContent":["(ns day8.re-frame-10x.navigation.epochs.events\n  (:require\n    [clojure.string                                               :as string]\n    [re-frame.core]\n    [re-frame.db]\n    [re-frame.trace]\n    [day8.re-frame-10x.inlined-deps.re-frame.v1v1v2.re-frame.core :as rf]\n    [day8.re-frame-10x.tools.metamorphic                          :as metam]\n    [day8.re-frame-10x.tools.coll                                 :as tools.coll]))\n\n(defn first-match-id\n  [m]\n  (-> m :match-info first :id))\n\n(rf/reg-event-fx\n  ::receive-new-traces\n  [rf/trim-v]\n  (fn [{:keys [db]} [new-traces]]\n    (if-let [sorted-traces (sort-by :id new-traces)]\n      (let [number-of-epochs-to-retain (get-in db [:settings :number-of-epochs])\n            events-to-ignore           (->> (get-in db [:settings :ignored-events]) vals (map :event-id) set)\n            previous-traces            (get-in db [:traces :all] [])\n            parse-state                (get-in db [:epochs :parse-state] metam/initial-parse-state)\n            {drop-re-frame :re-frame drop-reagent :reagent} (get-in db [:settings :low-level-trace])\n            all-traces                 (into previous-traces sorted-traces)\n            parse-state                (metam/parse-traces parse-state sorted-traces)\n            new-matches                (:partitions parse-state)\n            previous-matches           (get-in db [:epochs :matches] [])\n            parse-state                (assoc parse-state :partitions []) ;; Remove matches we know about\n            new-matches                (remove (fn [match]\n                                                 (let [event (get-in (metam/matched-event match) [:tags :event])]\n                                                   (contains? events-to-ignore (first event)))) new-matches)\n            ;; subscription-info is calculated separately from subscription-match-state because they serve different purposes:\n            ;; - subscription-info collects all the data that we know about the subscription itself, like its layer, inputs and other\n            ;;   things that are defined as part of the reg-sub.\n            ;; - subscription-match-state collects all the data that we know about the state of specific instances of subscriptions\n            ;;   like its reagent id, when it was created, run, disposed, what values it returned, e.t.c.\n            subscription-info          (metam/subscription-info (get-in db [:epochs :subscription-info] {}) sorted-traces (get-in db [:app-db :reagent-id]))\n            sub-state                  (get-in db [:epochs :sub-state] metam/initial-sub-state)\n            subscription-match-state   (metam/subscription-match-state sub-state all-traces new-matches)\n            subscription-matches       (rest subscription-match-state)\n\n            new-sub-state              (last subscription-match-state)\n            timing                     (mapv (fn [match]\n                                               (let [epoch-traces        (into []\n                                                                               (comp\n                                                                                 (tools.coll/id-between-xf (:id (first match)) (:id (last match))))\n                                                                               all-traces)\n                                                     ;; TODO: handle case when there are no epoch-traces\n                                                     start-of-epoch      (nth epoch-traces 0)\n                                                     ;; TODO: optimise trace searching\n                                                     event-handler-trace (first (filter metam/event-handler? epoch-traces))\n                                                     dofx-trace          (first (filter metam/event-dofx? epoch-traces))\n                                                     event-trace         (first (filter metam/event-run? epoch-traces))\n                                                     finish-run          (or (first (filter metam/finish-run? epoch-traces))\n                                                                             (tools.coll/last-in-vec epoch-traces))]\n                                                 {:re-frame/event-run-time     (metam/elapsed-time start-of-epoch finish-run)\n                                                  :re-frame/event-time         (:duration event-trace)\n                                                  :re-frame/event-handler-time (:duration event-handler-trace)\n                                                  :re-frame/event-dofx-time    (:duration dofx-trace)}))\n                                             new-matches)\n\n            new-matches                (map (fn [match sub-match t] {:match-info match\n                                                                     :sub-state  sub-match\n                                                                     :timing     t})\n                                            new-matches subscription-matches timing)\n            ;; If there are new matches found, then by definition, a quiescent trace must have been received\n            ;; However in cases where we reset the db in a replay, we won't get an event match.\n            ;; We short circuit here to avoid iterating over the traces when it's unnecessary.\n            quiescent?                 (or (seq new-matches)\n                                           (filter metam/quiescent? sorted-traces))\n            all-matches                (into previous-matches new-matches)\n            retained-matches           (into [] (take-last number-of-epochs-to-retain all-matches))\n            first-id-to-retain         (first-match-id (first retained-matches))\n            retained-traces            (into [] (comp (drop-while #(< (:id %) first-id-to-retain))\n                                                      (remove (fn [trace]\n                                                                (or (when drop-reagent (metam/low-level-reagent-trace? trace))\n                                                                    (when drop-re-frame (metam/low-level-re-frame-trace? trace)))))) all-traces)]\n        {:db       (-> db\n                       (assoc-in [:traces :all] retained-traces)\n                       (update :epochs (fn [epochs]\n                                         (let [selected-index (:selected-epoch-index epochs)\n                                               selected-id    (:selected-epoch-id epochs)]\n                                           (assoc epochs\n                                             :matches retained-matches\n                                             :matches-by-id (into {} (map (juxt first-match-id identity)) retained-matches)\n                                             :match-ids (mapv first-match-id retained-matches)\n                                             :parse-state parse-state\n                                             :sub-state new-sub-state\n                                             :subscription-info subscription-info\n                                             ;; Reset selected epoch to the head of the list if we got a new event in.\n                                             :selected-epoch-id (if (seq new-matches) (first-match-id (last retained-matches)) selected-id)\n                                             :selected-epoch-index (if (seq new-matches) nil selected-index))))))\n         :dispatch (when quiescent? [::quiescent])})\n      ;; Else\n      {:db db})))\n\n;; TODO: this code is a bit messy, needs refactoring and cleaning up.\n(rf/reg-event-fx\n  ::previous\n  [(rf/path [:epochs])]\n  (fn [{:keys [db]} _]\n    (if-some [selected-id (:selected-epoch-id db)]\n      (let [match-ids         (:match-ids db)\n            match-array-index (tools.coll/find-index-in-vec (fn [x] (= selected-id x)) match-ids)\n            new-id            (nth match-ids (dec match-array-index))]\n        {:db       (assoc db :selected-epoch-id new-id)\n         :dispatch [::reset-current-epoch-app-db new-id]})\n      (let [new-id (nth (:match-ids db)\n                        (- (count (:match-ids db)) 2))]\n        {:db       (assoc db :selected-epoch-id new-id)\n         :dispatch [::reset-current-epoch-app-db new-id]}))))\n\n\n(rf/reg-event-fx\n  ::next\n  [(rf/path [:epochs])]\n  (fn [{:keys [db]} _]\n    (if-some [selected-id (:selected-epoch-id db)]\n      (let [match-ids         (:match-ids db)\n            match-array-index (tools.coll/find-index-in-vec (fn [x] (= selected-id x)) match-ids)\n            new-id            (nth match-ids (inc match-array-index))]\n        {:db       (assoc db :selected-epoch-id new-id)\n         :dispatch [::reset-current-epoch-app-db new-id]})\n      (let [new-id (tools.coll/last-in-vec (:match-ids db))]\n        {:db       (assoc db :selected-epoch-id new-id)\n         :dispatch [::reset-current-epoch-app-db new-id]}))))\n\n(rf/reg-event-fx\n  ::most-recent\n  [(rf/path [:epochs])]\n  (fn [{:keys [db]} _]\n    (let [new-id (tools.coll/last-in-vec (:match-ids db))]\n      {:db       (assoc db :selected-epoch-index nil\n                           :selected-epoch-id new-id)\n       :dispatch [::reset-current-epoch-app-db new-id]})))\n\n(rf/reg-event-fx\n  ::load\n  [(rf/path [:epochs]) rf/trim-v]\n  (fn [{:keys [db]} [new-id]]\n    {:db       (assoc db :selected-epoch-id new-id)\n     :dispatch [::reset-current-epoch-app-db new-id]}))\n\n(rf/reg-event-db\n  ::replay\n  [(rf/path [:epochs])]\n  (fn [epochs _]\n    (let [selected-epoch-id (or (get epochs :selected-epoch-id)\n                                (tools.coll/last-in-vec (get epochs :match-ids)))\n          event-trace      (-> (get-in epochs [:matches-by-id selected-epoch-id :match-info])\n                               (metam/matched-event))\n          app-db-before    (metam/app-db-before event-trace)\n          event            (get-in event-trace [:tags :event])]\n      (reset! re-frame.db/app-db app-db-before)\n      ;; Wait for quiescence\n      (assoc epochs :replay event))))\n\n(rf/reg-event-db\n  ::quiescent\n  [(rf/path [:epochs])]\n  (fn [db _]\n    (if-some [event-to-replay (:replay db)]\n      (do (re-frame.core/dispatch event-to-replay)\n          (dissoc db :replay))\n      db)))\n\n(rf/reg-event-db\n  ::reset\n  (fn [db]\n    (re-frame.trace/reset-tracing!)\n    (-> db\n      (dissoc :epochs)\n      (tools.coll/dissoc-in [:traces :all]))))\n\n(rf/reg-event-db\n  ::reset-current-epoch-app-db\n  [rf/trim-v]\n  (fn [db [new-id]]\n    (when (get-in db [:settings :app-db-follows-events?])\n      (let [epochs   (:epochs db)\n            match-id (or new-id\n                         ;; new-id may be nil when we call this event from :settings/play\n                         (tools.coll/last-in-vec (get epochs :match-ids)))\n            match    (get-in epochs [:matches-by-id match-id])\n            event    (metam/matched-event (:match-info match))]\n        ;; Don't mess up the users app if there is a problem getting app-db-after.\n        (when-some [new-db (metam/app-db-after event)]\n          (reset! re-frame.db/app-db new-db))))\n    db))"]}